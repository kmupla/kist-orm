{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome","text":"<p>KIST ORM</p> <p>KIST ORM is a lightweight Object-Relational Mapping (ORM) framework designed specifically for Kotlin Native and Kotlin Multiplatform, with a primary focus on native desktop development. It currently targets SQLite exclusively.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The ecosystem for native desktop development with Kotlin is still growing, and options for database interaction are limited. The most prominent solution, SQLDelight, adopts a \"Database-First\" approach, generating type-safe Kotlin code from SQL files. While powerful, this approach requires developers to switch contexts between SQL files and Kotlin code and maps objects to queries rather than tables.</p> <p>Other older options like KTORM exist, but often rely on different philosophies or heavy reflection that might not be ideal for all native scenarios.</p> <p>KIST ORM was created to fill a specific gap: providing an annotation-based ORM experience similar to Android Room or Spring Data JPA, but tailored for the Kotlin Native environment.</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>KIST ORM follows a philosophy of developer convenience and familiarity:</p> <ul> <li>Annotation-Driven: Define your entities and queries using standard Kotlin classes and interfaces annotated with metadata (e.g., <code>@Entity</code>, <code>@Dao</code>, <code>@Query</code>).</li> <li>Compile-Time Generation: Leveraging KSP (Kotlin Symbol Processing), KIST generates the necessary boilerplate code (DAOs, metadata) during the build process. This ensures type safety and reduces runtime overhead.</li> <li>Native Focus: Targeted specifically at native desktop development.</li> <li>Familiarity: If you have used Room on Android, Spring Data JPA, or Hibernate, KIST's \"Code-First\" approach will feel right at home.</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>SQLite Support: Built on top of SQLite.</li> <li>Code Generation: Uses KSP to generate implementations for your DAOs.</li> <li>Simple API: Clean interfaces for database connections and transactions.</li> <li>Object Mapping: Maps logical entities directly to database tables.</li> </ul>"},{"location":"KIST_USAGE/","title":"Kist ORM Framework Usage","text":"<p>This project uses Kist, a custom ORM framework for Kotlin Native/Multiplatform, which shares similarities with Spring Data JPA and Android Room. Below is a guide on how to use it based on a PetShop example.</p>"},{"location":"KIST_USAGE/#1-entity-definition","title":"1. Entity Definition","text":"<p>Entities are Kotlin data classes annotated with <code>@Entity</code>. They map to database tables.</p>"},{"location":"KIST_USAGE/#annotations","title":"Annotations","text":"<ul> <li><code>@Entity(tableName = \"...\")</code>: Marks the class as an entity and specifies the table name.</li> <li><code>@PrimaryKeyColumn(\"...\")</code>: Marks the primary key field and its column name.</li> <li><code>@Column(\"...\")</code>: Maps a class property to a database column.</li> </ul>"},{"location":"KIST_USAGE/#example-petkt","title":"Example (<code>Pet.kt</code>)","text":"<pre><code>package com.example.petshop.model\n\nimport io.rss.knative.tools.kist.Column\nimport io.rss.knative.tools.kist.Entity\nimport io.rss.knative.tools.kist.PrimaryKeyColumn\nimport kotlinx.serialization.Serializable\n\n@Serializable\n@Entity(tableName = \"pets\")\ndata class Pet (\n\n    @PrimaryKeyColumn(\"id\")\n    var id: String,\n\n    @Column(\"name\")\n    var name: String,\n\n    @Column(\"type\")\n    var type: PetType,\n\n    @Column(\"owner_id\")\n    var ownerId: String?,\n\n    @Column(\"birth_date\")\n    var birthDate: Long,\n\n    @Column(\"status\")\n    var status: PetStatus,\n\n)\n</code></pre>"},{"location":"KIST_USAGE/#2-dao-definition","title":"2. DAO Definition","text":"<p>Data Access Objects (DAOs) are interfaces that define database operations. They must be annotated with <code>@Dao</code> and extend <code>KistDao</code>.</p>"},{"location":"KIST_USAGE/#basic-usage","title":"Basic Usage","text":"<p>Extend <code>KistDao&lt;Entity, ID_Type&gt;</code> to inherit basic CRUD operations.</p> <pre><code>@Dao\ninterface OwnerDao: KistDao&lt;Owner, String&gt; {\n}\n</code></pre>"},{"location":"KIST_USAGE/#custom-queries","title":"Custom Queries","text":"<p>Use the <code>@Query</code> annotation to define custom SQL queries. Method parameters can be bound to query parameters using the <code>:</code> prefix.</p>"},{"location":"KIST_USAGE/#example-petdaokt","title":"Example (<code>PetDao.kt</code>)","text":"<pre><code>@Dao\ninterface PetDao: KistDao&lt;Pet, String&gt; {\n\n    @Query(\"\"\"\n        SELECT * \n        FROM pets p \n        WHERE p.birth_date &gt;= :minBirthDate AND p.status = 'AVAILABLE'\n        ORDER BY p.birth_date\n        LIMIT 1\n    \"\"\")\n    fun findYoungestAvailablePet(minBirthDate: Long): Pet?\n\n    @Query(\"\"\"\n        SELECT MIN(p.birth_date) \n        FROM pets p \n        WHERE p.status = 'AVAILABLE'\n    \"\"\")\n    fun findOldestAvailablePetDate(): Long?\n\n    // Dynamic query parameters\n    @Query(\"\"\"\n        SELECT * \n        FROM pets p \n        WHERE p.status &lt;&gt; 'SOLD'  \n          AND (:petType IS NULL OR p.type = :petType)\n    \"\"\")\n    fun findAvailablePets(petType: PetType? = null): List&lt;Pet&gt;\n}\n</code></pre>"},{"location":"KIST_USAGE/#advanced-query-examples-orderdaokt","title":"Advanced Query Examples (<code>OrderDao.kt</code>)","text":"<p>The framework supports aggregation, <code>DELETE</code> operations, and <code>IN</code> clauses with list parameters.</p> <pre><code>@Dao\ninterface OrderDao: KistDao&lt;Order, String&gt; {\n\n    @Query(\"SELECT COUNT(*) as count FROM orders\")\n    fun countAllOrders(): Long?\n}\n\n@Dao\ninterface OrderItemDao: KistDao&lt;OrderItem, String&gt; {\n\n    @Query(\"DELETE FROM order_items WHERE order_id = :orderId\")\n    fun deleteByOrder(orderId: String)\n\n    // List parameter for IN clause\n    @Query(\"SELECT * FROM order_items WHERE product_id IN (:productIds)\")\n    fun findByProductIds(productIds: List&lt;String&gt;): List&lt;OrderItem&gt;\n}\n</code></pre>"},{"location":"KIST_USAGE/#3-configuration-initialization","title":"3. Configuration &amp; Initialization","text":"<p>The framework needs to be initialized with a database configuration and schema definitions.</p>"},{"location":"KIST_USAGE/#setup-steps","title":"Setup Steps","text":"<ol> <li>Define Schema: Prepare the SQL statements for creating tables.</li> <li>Create Connection: Use <code>PersistenceContext.createConnection</code> with <code>SqlLiteFileConfig</code>.</li> <li>Process Annotations: Call <code>PersistenceContext.processAnnotations()</code> to finalize setup.</li> </ol>"},{"location":"KIST_USAGE/#example-petshopconfigurerkt","title":"Example (<code>PetShopConfigurer.kt</code>)","text":"<pre><code>object PetShopConfigurer {\n\n    fun configureDb(filePath: String) {\n        // Prepare SQL schema statements\n        val sqlList = cleanUpSqlSource(R.DB_SCHEMA_SQL)\n            .plus(cleanUpSqlSource(Assets.INITIAL_DATA_SQL.decodeToString()))\n\n        // Ensure directory exists\n        Path(filePath).parent?.let {\n            Files.createDirectories(it)\n        }\n\n        // Initialize PersistenceContext\n        PersistenceContext.createConnection(\n            SqlLiteFileConfig(\"petshop.db.sqlite\",\n                path = filePath,\n                createStatements = sqlList))\n\n        // Process annotations (Essential step)\n        PersistenceContext.processAnnotations()\n    }\n\n    // ... helper methods ...\n}\n</code></pre>"},{"location":"KIST_USAGE/#4-transactions","title":"4. Transactions","text":"<p>There is a <code>Transactional</code> object in <code>com.example.petshop.dao.Transactional</code>, but it appears to be a placeholder implementation currently.</p> <pre><code>package com.example.petshop.dao\n\nimport kotlin.native.concurrent.ThreadLocal\n\n@ThreadLocal\nobject Transactional {\n    fun &lt;T&gt; runInTransaction(block: () -&gt; T): T {\n        // Placeholder: executes block directly\n        return block()\n    }\n}\n</code></pre>"},{"location":"KIST_USAGE/#5-dependencies","title":"5. Dependencies","text":"<p>The framework relies on: - <code>io.rss.knative.tools.kist.*</code> packages. - <code>kotlinx.serialization</code> (often used with Entities).</p>"},{"location":"configuration/","title":"Configuration","text":"<p>To use KIST ORM, you need to configure your build system to include the runtime library and the KSP processor.</p>"},{"location":"configuration/#dependencies","title":"Dependencies","text":"<p>Add the necessary dependencies to your <code>build.gradle.kts</code> (assuming Kotlin Multiplatform).</p>"},{"location":"configuration/#1-apply-ksp-plugin","title":"1. Apply KSP Plugin","text":"<p>First, apply the KSP plugin in your <code>plugins</code> block.</p> <pre><code>plugins {\n    kotlin(\"multiplatform\") \n    // Check for the latest KSP version compatible with your Kotlin version\n    id(\"com.google.devtools.ksp\") version \"2.2.0-2.0.2\" \n}\n</code></pre>"},{"location":"configuration/#2-add-library-dependencies","title":"2. Add Library Dependencies","text":"<p>Add the KIST API runtime library and the KSP processor to your source sets.</p> <pre><code>kotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                // KIST API Runtime\n                implementation(\"io.rss.knative.tools.kist:kist-api:1.0\") \n            }\n        }\n    }\n}\n\ndependencies {\n    // Register the KSP processor for metadata generation\n    add(\"kspCommonMainMetadata\", \"io.rss.knative.tools.kist:kist-ksp:1.0\")\n\n    // Register for specific targets (e.g., Apple targets, Linux, etc.)\n    // Replace 'kspApple' with your specific target configuration name if different\n    add(\"kspApple\", \"io.rss.knative.tools.kist:kist-ksp:1.0\")\n}\n</code></pre> <p>::: note Adjust the version numbers (<code>1.0</code> or similar) to match the version of KIST you are using. :::</p>"},{"location":"configuration/#setup-explanation","title":"Setup Explanation","text":"<p>KIST relies heavily on KSP (Kotlin Symbol Processing) to bridge the gap between your annotated interfaces and the actual database calls.</p> <ol> <li>Annotation Processing: When you build your project, KSP scans your code for <code>@Entity</code> and <code>@Dao</code> annotations.</li> <li>Code Generation: The <code>kist-ksp</code> processor generates implementation classes (like <code>MyDaoImpl</code>) and metadata registries that map your classes to the database schema.</li> <li>Runtime Registration: The generated code interacts with <code>PersistenceContext</code> at runtime.</li> </ol>"},{"location":"configuration/#native-linker-options","title":"Native Linker Options","text":"<p>Since KIST uses the <code>sqlite3</code> C library, you must ensure your native target links against it.</p> <pre><code>kotlin {\n    nativeTarget.apply {\n        binaries {\n            executable {\n                // Link against SQLite3\n                linkerOpts.add(\"-lsqlite3\")\n                // additional params might be needed for Windows\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"configuration/#unresolved-reference-injectdao-or-similar-errors","title":"\"Unresolved reference: injectDao\" or similar errors","text":"<p>If the compiler cannot find generated code or extensions:</p> <ol> <li>Ensure the KSP plugin is applied.</li> <li>Ensure you have added the <code>kist-ksp</code> dependency to the correct configuration (e.g., <code>kspKotlinApple</code>, <code>kspNative</code>, etc.).</li> <li>Try running a generic <code>./gradlew clean build</code> to force KSP to run.</li> </ol>"},{"location":"database_access/","title":"Database Access","text":"<p>Connecting to the database and setting up the persistence context is the first step in using KIST ORM effectively.</p>"},{"location":"database_access/#persistence-context","title":"Persistence Context","text":"<p>The <code>PersistenceContext</code> object acts as the central hub for database configuration and connection management.</p>"},{"location":"database_access/#initialization","title":"Initialization","text":"<p>You must initialize the connection before performing any database operations. This usually happens in your application's <code>main()</code> function or startup logic.</p> <pre><code>import io.knative.kist.config.PersistenceContext\nimport io.knative.kist.config.SqlLiteFileConfig\n// Import the generated processAnnotations method (often in a specific package, check your generated code or docs)\n// Typically acts as an extension or static call\nimport io.knative.kist.processed.KistRegister.processAnnotations \n\nfun initDatabase() {\n    // 1. Create Connection\n    PersistenceContext.createConnection(\n        SqlLiteFileConfig(\n            dbName = \"app.db\",\n            path = \"/var/lib/myapp/db/\", // Optional: defaults to working dir if omitted\n            createStatements = listOf(\n                 \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)\",\n                 \"CREATE TABLE IF NOT EXISTS pets (id INTEGER PRIMARY KEY, name TEXT, owner_id INTEGER)\"\n            )\n        )\n    )\n\n    // 2. Process Annotations (Register Generated Code)\n    // This step is critical. It loads the metadata generated by KSP so the framework knows about your Entities and DAOs.\n    PersistenceContext.processAnnotations()\n}\n</code></pre>"},{"location":"database_access/#configuration-options","title":"Configuration Options","text":""},{"location":"database_access/#sqllitefileconfig","title":"SqlLiteFileConfig","text":"<p>Used for standard, persistent file-based SQLite databases.</p> <ul> <li><code>dbName</code>: The name of the database file (e.g., <code>data.sqlite</code>).</li> <li><code>path</code>: Directory path where the file is stored.</li> <li><code>createStatements</code>: A list of SQL statements to execute immediately after opening the connection. This is the recommended place to define your schema (<code>CREATE TABLE</code>, etc.) if you don't use an external migration tool.</li> </ul>"},{"location":"database_access/#inmemoryconfig","title":"InMemoryConfig","text":"<p>Used primarily for unit testing or temporary data storage that should not persist after the application closes.</p> <pre><code>import io.knative.kist.config.InMemoryConfig\n\nPersistenceContext.createConnection(\n    InMemoryConfig(\n        dbName = \"test.db\",\n        createStatements = schemaSqlList\n    )\n)\n</code></pre>"},{"location":"database_access/#accessing-the-connection","title":"Accessing the Connection","text":"<p>While you will primarily interact with the database through DAOs, you can access the underlying connection directly for advanced use cases or raw SQL execution.</p> <pre><code>val connection = PersistenceContext.connection\n\n// Execute a raw statement\nconnection.withStatement(\"INSERT INTO logs (msg) VALUES (?)\") {\n    bindString(1, \"Log message\")\n    execute()\n}\n</code></pre>"},{"location":"database_access/#transactions","title":"Transactions","text":"<p>KIST provides basic transaction support. (Refer to specific <code>Transactional</code> helpers or direct connection API if available in your version).</p> <pre><code>// Example placeholder for transaction context\n// Transactional.runInTransaction {\n//     dao.insert(item1)\n//     dao.insert(item2)\n// }\n</code></pre>"},{"location":"entities/","title":"Entities","text":"<p>Entities are the core of your data model in KIST ORM. They represent the tables in your SQLite database.</p>"},{"location":"entities/#defining-an-entity","title":"Defining an Entity","text":"<p>To define an entity, create a Kotlin <code>data class</code> and annotate it with <code>@Entity</code>. Use <code>@Column</code> and <code>@PrimaryKeyColumn</code> to map properties to database columns.</p> <pre><code>import io.knative.kist.Entity\nimport io.knative.kist.Column\nimport io.knative.kist.PrimaryKeyColumn\n\n@Entity(tableName = \"pets\")\ndata class Pet(\n    @PrimaryKeyColumn(\"id\")\n    var id: String,\n\n    @Column(\"name\")\n    var name: String,\n\n    @Column(\"age\")\n    var age: Int,\n\n    @Column(\"is_adopted\")\n    var isAdopted: Boolean = false,\n\n    @Column(\"birth_date\")\n    var birthDate: Long // Store dates as timestamps (INTEGER)\n)\n</code></pre>"},{"location":"entities/#supported-annotations","title":"Supported Annotations","text":""},{"location":"entities/#entity","title":"<code>@Entity</code>","text":"<p>Marks a class as a database entity. *   <code>tableName</code>: Required. Specifies the name of the corresponding table in the database.</p>"},{"location":"entities/#primarykeycolumn","title":"<code>@PrimaryKeyColumn</code>","text":"<p>Marks a property as the primary key of the table. *   <code>name</code>: Required. The column name in the database. *   Constraint: Every entity must have exactly one property annotated with <code>@PrimaryKeyColumn</code>.</p>"},{"location":"entities/#column","title":"<code>@Column</code>","text":"<p>Maps a standard property to a database column. *   <code>name</code>: Required. The column name in the database.</p>"},{"location":"entities/#data-types","title":"Data Types","text":"<p>KIST maps Kotlin types to SQLite types as follows:</p> Kotlin Type SQLite Type Notes <code>String</code> <code>TEXT</code> <code>Int</code> <code>INTEGER</code> <code>Long</code> <code>INTEGER</code> <code>Boolean</code> <code>INTEGER</code> Stored as <code>1</code> (true) or <code>0</code> (false). <code>Double</code> <code>REAL</code>"},{"location":"entities/#complex-types-enums-dates","title":"Complex Types (Enums, Dates)","text":"<p>Currently, KIST supports primarily primitive types. For complex types like <code>Enum</code> or <code>LocalDateTime</code>, you typically need to store them as primitives (e.g., <code>String</code>, <code>Int</code>, or <code>Long</code>) and handle the conversion manually or via property accessors if specific type converters are not yet configured.</p> <p>Example with Enum:</p> <pre><code>enum class PetType { DOG, CAT }\n\n@Entity(tableName = \"animals\")\ndata class Animal(\n    @PrimaryKeyColumn(\"id\") var id: Int,\n    @Column(\"type\") var typeString: String // Store as string\n) {\n    // Helper property to work with Enum in code\n    var type: PetType\n        get() = PetType.valueOf(typeString)\n        set(value) { typeString = value.name }\n}\n</code></pre>"},{"location":"get_started/","title":"Get Started","text":"<p>This guide will help you get up and running with KIST ORM in your Kotlin Native project.</p>"},{"location":"get_started/#why-use-kist-orm","title":"Why Use KIST ORM?","text":"<ul> <li>Productivity: Write less boilerplate code. specific implementations are generated for you.</li> <li>Readability: Keep your database logic near your domain code using annotated interfaces.</li> <li>Performance: Generated code is optimized for Kotlin Native.</li> </ul>"},{"location":"get_started/#minimal-example","title":"Minimal Example","text":""},{"location":"get_started/#1-define-an-entity","title":"1. Define an Entity","text":"<pre><code>import io.knative.kist.Entity\nimport io.knative.kist.PrimaryKeyColumn\nimport io.knative.kist.Column\n\n@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKeyColumn(\"id\") var id: Long,\n    @Column(\"name\") var name: String\n)\n</code></pre>"},{"location":"get_started/#2-define-a-dao","title":"2. Define a DAO","text":"<pre><code>import io.knative.kist.Dao\nimport io.knative.kist.KistDao\nimport io.knative.kist.Query\n\n@Dao\ninterface UserDao : KistDao&lt;User, Long&gt; {\n    @Query(\"SELECT * FROM users WHERE name = ?\")\n    fun findByName(name: String): List&lt;User&gt;\n}\n</code></pre>"},{"location":"get_started/#3-usage","title":"3. Usage","text":"<pre><code>import io.knative.kist.config.PersistenceContext\nimport io.knative.kist.config.SqlLiteFileConfig\nimport io.knative.kist.injectDao\n\nfun main() {\n    // 1. Initialize Connection\n    PersistenceContext.createConnection(\n        SqlLiteFileConfig(\n            dbName = \"my_app.db\",\n            createStatements = listOf(\n                \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)\"\n            )\n        )\n    )\n\n    // 2. Process Annotations (Register Generated Code)\n    PersistenceContext.processAnnotations()\n\n    // 3. Use DAO\n    val userDao: UserDao by injectDao() \n\n    val user = User(1, \"Alice\")\n    userDao.insert(user)\n\n    val alice = userDao.findByName(\"Alice\")\n    println(alice)\n}\n</code></pre>"},{"location":"queries/","title":"Queries &amp; DAOs","text":"<p>Data Access Objects (DAOs) provide the abstract interface to your database. They allow you to perform CRUD operations and execute custom SQL queries without writing boilerplate code.</p>"},{"location":"queries/#defining-a-dao","title":"Defining a DAO","text":"<p>To create a DAO, define an interface that extends <code>KistDao&lt;Entity, ID_Type&gt;</code> and annotate it with <code>@Dao</code>.</p> <pre><code>import io.knative.kist.Dao\nimport io.knative.kist.KistDao\nimport io.knative.kist.Query\n\n@Dao\ninterface PetDao : KistDao&lt;Pet, String&gt; {\n    // KistDao provides built-in methods:\n    // - insert(entity: Pet)\n    // - update(entity: Pet)\n    // - deleteById(id: String)\n    // - findById(id: String): Pet?\n    // - findAll(): List&lt;Pet&gt;\n    // - exists(id: String): Boolean\n}\n</code></pre>"},{"location":"queries/#custom-queries","title":"Custom Queries","text":"<p>You can define custom operations using the <code>@Query</code> annotation.</p>"},{"location":"queries/#basic-selection","title":"Basic Selection","text":"<p>Use standard SQL syntax.</p> <pre><code>@Query(\"SELECT * FROM pets WHERE name = 'Fido'\")\nfun findFido(): Pet?\n</code></pre>"},{"location":"queries/#parameter-binding","title":"Parameter Binding","text":"<p>~Bind method parameters to your query using the <code>:</code> prefix.~ (not yet available)</p> <pre><code>@Query(\"SELECT * FROM pets WHERE name = ?\")\nfun findByName(name: String): List&lt;Pet&gt;\n\n@Query(\"SELECT * FROM pets WHERE age &gt;= ?\")\nfun findOlderThan(minAge: Int): List&lt;Pet&gt;\n</code></pre> <p>Bind the parameters using <code>?</code> and declaring the parameters in the same order:</p> <pre><code>@Query(\"SELECT * FROM person_table WHERE name like ? AND street like ?\")\nfun findByNameStreet(name: String, streetPart: String): List&lt;Person&gt;\n</code></pre>"},{"location":"queries/#dynamic-parameters-null-checks","title":"Dynamic Parameters &amp; Null Checks","text":"<p>KIST supports checking for optional parameters directly in SQL.</p> <pre><code>// If type is null, ignore the filter (return all types)\n@Query(\"SELECT * FROM pets WHERE (? IS NULL OR type = ?)\")\nfun findByType(type: String?, type: String?): List&lt;Pet&gt;\n</code></pre>"},{"location":"queries/#list-parameters-in-clause","title":"List Parameters (IN Clause)","text":"<p>You can pass lists to handle SQL <code>IN</code> clauses.</p> <pre><code>@Query(\"SELECT * FROM pets WHERE id IN (?)\")\nfun findByIds(ids: List&lt;String&gt;): List&lt;Pet&gt;\n</code></pre>"},{"location":"queries/#aggregations-and-dtos","title":"Aggregations and DTOs","text":"<p>Queries are not restricted to returning Entities. You can return primitives, counts, or custom Data Transfer Objects (DTOs).</p> <pre><code>data class PetSummary(val name: String, val age: Int)\n\n@Dao\ninterface PetDao : KistDao&lt;Pet, String&gt; {\n\n    @Query(\"SELECT count(*) FROM pets\")\n    fun countAll(): Long\n\n    // Mapping columns to DTO properties automatically\n    @Query(\"SELECT name, age FROM pets WHERE is_adopted = 1\")\n    fun getAdoptedSummaries(): List&lt;PetSummary&gt;\n}\n</code></pre>"},{"location":"queries/#injecting-daos","title":"Injecting DAOs","text":"<p>Once your DAOs are defined and the application is configured, you can inject them into your services or controllers.</p> <p>Use the <code>injectDao</code> delegate for lazy retrieval.</p> <pre><code>import io.knative.kist.injectDao\n\nobject PetService {\n    // Automatically finds the generated implementation for PetDao\n    private val petDao: PetDao by injectDao()\n\n    fun registerPet(pet: Pet) {\n        petDao.insert(pet)\n    }\n\n    fun find(id: String) = petDao.findById(id)\n}\n</code></pre> <p>Note: Ensure <code>PersistenceContext.processAnnotations()</code> is called at startup before accessing any injected DAO.</p>"}]}